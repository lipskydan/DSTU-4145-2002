# DSTU-4145-2002

<table>
    <tr>
        <td align="center"> No ч/ч </td>
        <td align="center"> Степінь поля m </td> 
        <td align="center"> Примітивний многочлен </td>
    </tr>
     <tr>
        <td align="center"> 4 </td>
        <td align="center"> 179 </td> 
        <td align="center"> x^179 + x^4 + x^2 + x + 1 </td>
    </tr>
</table>

## Реалізація алгоритму поділена на наступні логічні частини:
* [sha256.py - реалізує хеш-функцію SHA-256](#sha256)
* [GF.py - реалізує операції над поліномами над полем Галуа GF(2^m)](#GF)
* [ecc.py - реалізує операції над еліптичними кривими та їх точками над GF(2^m)](#ecc)
* [signature.py - реалізує алгоритм цифрового підпису еліптичної кривої](#signature)


### <a name="sha256"></a> Хеш-функцію SHA-256

Даний алгоритм було розглянуто в рамках минулої лабораторної роботи. Детальний опис представленно за 
[посиланням](https://github.com/lipskydan/SHA-256). 


### <a name="GF"></a> Поле Галуа GF(2^m)

<p align="justify">
Для роботи з інформацією під час кодування та декодування даних усі арифметичні операції виконуються
у полях Галуа. Застосовується так звана поліноміальна арифметика чи арифметика полів Галуа.
Таким чином, результат будь-якої операції є елементом даного поля.
Конкретне поле Галуа складається із фіксованого діапазону чисел. Характеристики поля називають
деяке просте число p. порядок поля, тобто кількість його елементів, є деякою натуральною
ступенем характеристики pm, де m∈N. При m=1 поле називається простим. У випадках, коли m>1,
для утворення поля необхідний ще породжує поліном ступеня m, таке поле називається розширеним.
GF(p^m) – позначення поля Галуа.

В рамках цієї частини було реалізовано операції над поліномами над полем Галуа

* операція додавання є простим побітовим додаванням по модулю 2 (XOR)
* Множення в скінченному полі є множенням за модулем незвідного редукторного полінома, який використовується для 
визначення скінченного поля. Тобто, це множення з подальшим діленням із використанням зменшуваного полінома як дільника, 
залишок є добутком.
* Мультиплікативне обернення для елемента a скінченне поле можна обчислити наступним способом: оскільки ненульові 
елементи GF(p^m) утворюють скінченну групу відносно множення, a^(p^(m)−1) = 1 (для a ≠ 0), отже, оберненою до a є 
a^(p^(m)−2).
* Піднесення до квадрату реалізовано на основі множення
* Піднесення до довільної степені реалізовано на основі множення та піднесення до квадрату
* Ділення обчислюється за формулою - а mul b^(p^(m)−2)
</p>

### <a name="ecc"></a> Операції над еліптичними кривими та їх точками над GF(2^m)

#### Додавання точок

З двома різними точками, P і Q, додавання визначається як заперечення точки, отриманої в результаті перетину кривої E,
і прямої, визначеної точками P і Q, що дає точку R.

P+Q=R
(x_{p}, y_{p}) + (x_{q}, y_{q}) = (x_{r}, y_{r})
Припускаючи, що еліптична крива E задається формулою y^2 = x^3 + ax + b , її можна обчислити так:

lambda =(y_{q} - y_{p}) / (x_{q} - x_{p})

x_{r} = lambda^2 - x_{p} - x_{q} 

y_{r} = lambda * (x_{p} - x_{r}) - y_{p}

Ці рівняння правильні, коли жодна точка не є точкою на нескінченності та якщо точки мають різні координати x 
(вони не є взаємно оберненими).

#### Подвоєння точок

Якщо точки P і Q збігаються (в одних і тих же координатах), додавання подібне, за винятком того, що немає чітко 
визначеної прямої через P, тому операція замикається, використовуючи граничний випадок, дотичну до кривої, E , в точці 
P.

Це розраховується беручи похідні (dE/dx)/(dE/dy):

lambda =(3x * p^2 + a) / 2yp

#### Множення точок

Обчислення множення точки полягає в повторному додаванні

    нехай res = 0 # точка на нескінченності
    для біт у бітах:
       res = res + res # def double_point
       якщо біт == 1:            
           res = res + P # def add_points
       i = i - 1
    повернути рез

#### Пошук базової точки 

1. Обчислюємо порядок N еліптичної кривої.
2. Вибираємо порядок n підгрупи. Щоб алгоритм спрацював, число має бути простим і дільником N. 
3. Обчислюємо кофактор h = N / n. 
4. Вибираємо на кривій випадкову точку P. 
5. Обчислюємо G = hP. 
6. Якщо G дорівнює 0, то повертаємося до кроку 4. Інакше ми знайшли генератор підгрупи з порядком n та кофактором h.

### <a name="signature"></a> Алгоритм цифрового підпису еліптичної кривої

#### Код підписання

    ec = EllipticCurve(GF())
    base_point = ec.base_point()
    ds = DigitalSignature(ec, base_point)

    d = ds.gen_private_key()
    print(f'private key = {d}')

    Q = ds.gen_public_key(d)
    print(f'public key = {Q}')

    message = os.urandom(16)
    print(f'message = {message}')

    signature = ds.sign(message, d)[1]
    print(f'signature = {signature}')

#### Результат

![img_1](img_for_readme/img_1.png)

#### Код верифікації

    class TestDigitalSignature(unittest.TestCase):

        def test_sign(self):
            ec = EllipticCurve(GF())
            base_point = ec.base_point()
            ds = DigitalSignature(ec, base_point)
            d = ds.gen_private_key()
            Q = ds.gen_public_key(d)
            message = os.urandom(16)
            message, signature = ds.sign(message, d)
            self.assertTrue(ds.verify(message, signature, Q))

    if __name__ == '__main__':
    unittest.main()

#### Результат

![img_2](img_for_readme/img_2.png)
